# 简介
Xross workflow，简称为xflow，是一个轻量级工作流，包括IDEA编辑器和运行时。 

xflow利用本地文件来存储模型，其编辑和运行都无需依赖第三方服务器或数据库。

xflow支持丰富的活动节点和路由节点，支持子图调用，监听器和灵活的工作流相关操作。

<img width="1436" height="1160" alt="image" src="https://github.com/user-attachments/assets/ab3686c2-00fd-417c-a8b5-d4621b486d0e" />


# 快速体验

# 编辑器使用教程

## 安装
### 插件市场安装
正常来说在IDEA插件市场输入xross workflow即可，但目前IDEA的插件市场存在一些问题，导致某些版本的IDEA无法兼容xflow插件。该问题还没有完全解决。因此当前只能从github手动下载xflow安装包。

### 手动安装
下载后直接拖入IDEA即可。xflow依赖
[插件]()

## 创建模型
### 创建xflow模型文件
选中项目的resources目录，然后通过File->New->Xross Flow Model打开模型名字输入框，输入模型名字即可
<img width="547" height="851" alt="image" src="https://github.com/user-attachments/assets/dd92c10c-98d1-4de3-8787-491f00f2d0bc" />

### 编辑xflow模型文件
通过编辑窗口左侧的组件菜单来选择和放置相关节点，通过Link菜单来连接两个节点

右侧的outline窗口提供模型文件的结构，选中编辑窗口中的已有节点或连接，也会相应的选中在outline窗口，选中outline窗口中的元素，也会选中编辑窗口中的对应组件（可显示的）

## 模型概念
一个xflow模型文件可以包括0到多个xflow模型，每个xflow模型都有一个单独的编辑窗口，每个xflow模型可以包含多个节点，节点分为开始，结束节点，活动节点和路由节点。节点间可以有连线。

xflow模型，节点和连线都需要有对应的ID。其中xflow的ID在当前模型文件中需要唯一，节点ID需要仅需在当前xflow中唯一，连线ID仅需在相同源路由节点的连线中保持唯一。

当前xflow模型文件，每个xflow模型，每个节点都可以增加任意多自定义属性，节点可以通过实现特定接口来获得这些属性。

## 工作流实例状态
利用XflowFactory可以基于xflow模型文件创建工作流实例。实例状态为以下几种：

* CREATED：已创建，未执行
* RUNNING：运行状态，当前流程有活跃节点或失败节点
* SUSPENDED：暂停状态，由程序主动发起的suspend操作导致
* SUCCEED：流程执行到结束节点，流程成功结束
* FAILED：当前没有任何活跃或失败的节点，并且没有执行到结束节点
* ABORTED：废弃状态，由程序主动发起的abort操作导致

## 节点状态
节点有两个状态维度，分别是：
* isActive：是否活跃
* isFailed：是否失败

任一时间，一个节点只会有最多一个活动实例，因此节点对应的操作不会出现并发调用现象。

在节点处于活跃状态的时候，如果节点执行失败，节点将保持活跃，并进入失败状态，可以通过retry进行重试

# 开始结束节点
Start和End节点分别为开始和结束节点。

xflow开始执行时会找到当前xflow模型中第一个Start节点并创建一个ActiveToken去调用该Start节点。

当任意节点后继执行到End节点时，xflow流程实例结束，当前所有活跃节点执行完毕后，不会继续执行后继节点。

## 活动节点
Xflow支持5种活动节点。分别是自动节点，任务节点，事件节点，延时等待节点和子流程节点。

除延时等待节点外，其他4个活动节点均需用户实现相应接口。活动节点通用属性如下所示：

<img width="1143" height="223" alt="image" src="https://github.com/user-attachments/assets/fd477cca-e5b1-4b9f-8b43-c1d99b37852a" />

* Id: 节点在当前模型中的唯一标识符，如果用户没有设置Label，则节点图形上将显示Id
* Label：可选节点标签。如果用户设置了该属性，则节点图形上将显示该值
* Description：可选节点描述
* Implementation：节点对应接口实现类，延时等待节点无此属性

如果用户没有为节点定义自定义属性，则将不显示Misc和Properties分类标志，反之上述属性将显示在Misc大类下，用户自定义属性将显示在Properties大类下

### 自动节点
Auto activity是自动节点，当流程实例执行到该节点，会调用AutoActivity接口实现：

    package com.xrosstools.xflow;
    
    public interface AutoActivity {
    	void execute(XflowContext context);
    }

例如：


    public class TestAutoActivity extends TestAdapter implements AutoActivity, NodeConfigAware {
    	public static final String PROP_KEY_COUNTER = "counter";
    	public static final String PROP_KEY_STEP = "step";
    
    	private int step;
    	@Override
    	public void execute(XflowContext context) {
    		call(context);
    
    		AtomicInteger counter = context.get(PROP_KEY_COUNTER);
    		counter.addAndGet(step);
    	}
    
    	@Override
    	public void initNodeConfig(DataMap config) {
    		step = config.get(PROP_KEY_STEP);
    	}
    }

备注：
实例代码中的用到的基类TestAdapter和调用的方法call(context)，以及下面会出现的injectException，injectSuspend等仅仅是为完成测试用的代码，与具体接口无关，请忽略。

### 任务节点
Task activity是任务节点，当流程实例执行到该节点，会调用TaskActivity接口实现：

    package com.xrosstools.xflow;
    
    import java.util.List;
    
    public interface TaskActivity {
    	/**
    	 * Create tasks that need to be handled
    	 * @param context the execution context
    	 * @return id that differentiates tasks created each time  
    	 */
    	List<Task> create(XflowContext context);
    
    	/**
    	 * Submit a task
    	 * @param context the execution context
    	 * @param tasks all the tasks that are generated by create method
    	 * @param task current task that user submitted
    	 * @return true if activity completed
    	 */
    	boolean submit(XflowContext context, List<Task> tasks, Task task);
    }

例如：

    public class TestTaskActivity extends TestAdapter implements TaskActivity, NodeConfigAware, FlowConfigAware {
    	private int count;
    	private String assignee;
    
    	@Override
    	public void initFlowConfig(DataMap config) {
    		assignee = config.get("assignee");
    	}
    
    	@Override
    	public void initNodeConfig(DataMap config) {
    		count = config.get("count");		
    	}
    
    	@Override
    	public List<Task> create(XflowContext context) {
    		call(context);
    		List<Task> tasks = new ArrayList<>();
    		for(int i = 0; i < count; i++) {
    			tasks.add(new FeedbackTask("id_" + i, assignee));
    		}
    		System.out.println("Task generated: " + tasks.size());
    		return tasks;
    	}
    
    	@Override
    	public boolean submit(XflowContext context, List<Task> tasks, Task task) {
    		call(context);
    		return ((FeedbackTask)task).getFeedback().equals("OK");
    	}
    }

### 事件节点
Event activity是事件节点，当流程实例执行到该节点，会调用EventActivity接口实现：

    package com.xrosstools.xflow;
    
    public interface EventActivity {
    	EventSpec specify(XflowContext context);
    
    	void notify(XflowContext context, Event event);
    }

例如：

    public class TestEventActivity extends TestAdapter implements EventActivity, NodeConfigAware  {
    	public static final String EVENT_ID = "event id";
    	private String eventId;
    	@Override
    	public EventSpec specify(XflowContext context) {
    		call(context);
    		return new EventSpec(eventId);
    	}
    
    	@Override
    	public void notify(XflowContext context, Event event) {
    		call(context);
    		if(!event.getId().equals(eventId))
    			throw new IllegalArgumentException();
    	}
    
    	@Override
    	public void initNodeConfig(DataMap config) {
    		eventId = config.get(EVENT_ID);
    	}
    }


### 延时等待节点
Wait activity是延时等待节点，当流程实例执行到该节点，会等待给定时间再进入到后继节点，其属性如下：

<img width="1171" height="190" alt="image" src="https://github.com/user-attachments/assets/fc90d4c4-16a6-40c3-a77a-37f528836f90" />

* Delay：是要延时的数值
* Time unit：延时数值对应的单位：

<img width="236" height="151" alt="image" src="https://github.com/user-attachments/assets/18b5a8b5-8224-4a51-84d3-18ed47e2c7d9" />

### 子流程节点
Subflow activity是子流程节点节点，该节点属性如下：

<img width="1173" height="160" alt="image" src="https://github.com/user-attachments/assets/39e311cc-43a3-478a-a1a7-c0388ddc6de5" />

* Subflow：当前模型文件中某个xflow模型的ID

当前不支持跨模型文件的子流程调用，未来版本会支持

当流程实例执行到该节点，会调用SubflowActivity接口实现：

    package com.xrosstools.xflow;
    
    public interface SubflowActivity {
    	XflowContext createContext(XflowContext parentContext);
    	void mergeSubflow(XflowContext parentContext, XflowContext subFlowContext);
    }

例如：

    public class TestSubflowActivity extends TestAdapter implements SubflowActivity {
    	public static final String COUNT = "count";
    	public static final String ERROR = "error";
    
    	@Override
    	public XflowContext createContext(XflowContext parentContext) {
    		call(parentContext);
    
    		XflowContext subflowContext = new XflowContext();
    		
    		if(parentContext.contains(ERROR))
    			injectException(subflowContext, (Exception)subflowContext.get(ERROR));
    		
    		if(parentContext.contains(SUB_FLOW_SUSPEND))
    			injectSuspend(subflowContext, nodeStarted, START_NODE);
    		
    		int count = parentContext.get(COUNT);
    		subflowContext.put(TestAutoActivity.PROP_KEY_COUNTER, new AtomicInteger(count));
    		
    		return subflowContext;
    	}
    
    	@Override
    	public void mergeSubflow(XflowContext parentContext, XflowContext subFlowContext) {
    		call(parentContext);
    
    		AtomicInteger counter = subFlowContext.get(TestAutoActivity.PROP_KEY_COUNTER);
    		parentContext.put(COUNT, counter.get());
    	}
    }

## 路由节点
## 自定义配置
## 帮助类

# 模型调用
## 流程实例操作
## 节点操作
## Spring支持
## 持久化
## 监听器


